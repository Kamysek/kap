# This file was generated based on "schema.json". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"An object with an ID"
interface Node {
  "The ID of the object."
  id: ID!
}

type AppointmentType implements Node {
  appointmentEnd: DateTime
  appointmentStart: DateTime
  commentDoctor: String
  commentPatient: String
  createdAt: DateTime
  dayReminder: Boolean!
  "The ID of the object."
  id: ID!
  patient: UserType
  taken: Boolean!
  title: String
  weekReminder: Boolean!
}

type AppointmentTypeConnection {
  "Contains the nodes in this connection."
  edges: [AppointmentTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `AppointmentType` and its cursor."
type AppointmentTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AppointmentType
}

type BoardType implements Node {
  creator: UserType
  description: String
  "The ID of the object."
  id: ID!
  name: String
  topicSet(
    after: String
    before: String
    first: Int
    last: Int
  ): TopicTypeConnection!
}

type BoardTypeConnection {
  "Contains the nodes in this connection."
  edges: [BoardTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `BoardType` and its cursor."
type BoardTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: BoardType
}

type CheckupType implements Node {
  "The ID of the object."
  id: ID!
  interval: Int
  name: String
  order: Int
  study: StudyType
}

type CheckupTypeConnection {
  "Contains the nodes in this connection."
  edges: [CheckupTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `CheckupType` and its cursor."
type CheckupTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: CheckupType
}

type ChoiceAnswerType implements Node {
  choiceAnswer: ChoiceType
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  question: QuestionType
  updatedOn: DateTime
}

type ChoiceAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [ChoiceAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `ChoiceAnswerType` and its cursor."
type ChoiceAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: ChoiceAnswerType
}

type ChoiceType implements Node {
  choiceText: String!
  choiceanswerSet(
    after: String
    before: String
    first: Int
    last: Int
  ): ChoiceAnswerTypeConnection!
  "The ID of the object."
  id: ID!
  question: QuestionType!
}

type ChoiceTypeConnection {
  "Contains the nodes in this connection."
  edges: [ChoiceTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `ChoiceType` and its cursor."
type ChoiceTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: ChoiceType
}

type CreateAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
}

type CreateBoardPayload {
  board: BoardType
  clientMutationId: String
}

type CreateChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
}

type CreateChoicePayload {
  choice: ChoiceType
  clientMutationId: String
}

type CreateGroupPayload {
  clientMutationId: String
  group: GroupType
}

type CreateNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
}

type CreatePostPayload {
  clientMutationId: String
  post: PostType
}

type CreateQuestionPayload {
  clientMutationId: String
  question: QuestionType
}

type CreateSurveyPayload {
  clientMutationId: String
  survey: SurveyType
}

type CreateTextAnswerPayload {
  clientMutationId: String
  textAnswer: TextAnswerType
}

type CreateTopicPayload {
  clientMutationId: String
  topic: TopicType
}

type CreateUserPayload {
  clientMutationId: String
  user: UserType
}

type DeleteAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
  ok: Boolean
}

type DeleteBoardPayload {
  board: BoardType
  clientMutationId: String
  ok: Boolean
}

type DeleteChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
  ok: Boolean
}

type DeleteChoicePayload {
  choice: ChoiceType
  clientMutationId: String
  ok: Boolean
}

type DeleteNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
  ok: Boolean
}

type DeletePostPayload {
  clientMutationId: String
  ok: Boolean
  post: TopicType
}

type DeleteQuestionPayload {
  clientMutationId: String
  ok: Boolean
  question: QuestionType
}

type DeleteSurveyPayload {
  clientMutationId: String
  ok: Boolean
  survey: SurveyType
}

type DeleteTextAnswerPayload {
  clientMutationId: String
  ok: Boolean
  textAnswer: TextAnswerType
}

type DeleteTopicPayload {
  clientMutationId: String
  ok: Boolean
  topic: TopicType
}

type DeleteUserPayload {
  clientMutationId: String
  ok: Boolean
  user: UserType
}

type GroupType implements Node {
  "The ID of the object."
  id: ID!
  name: String!
  "The groups this user belongs to. A user will get all permissions granted to each of their groups."
  userSet(
    after: String
    before: String
    first: Int
    last: Int
  ): UserTypeConnection!
}

type GroupTypeConnection {
  "Contains the nodes in this connection."
  edges: [GroupTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `GroupType` and its cursor."
type GroupTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: GroupType
}

type Mutation {
  createAppointment(input: CreateAppointmentInput!): CreateAppointmentPayload
  createBoard(input: CreateBoardInput!): CreateBoardPayload
  createChoice(input: CreateChoiceInput!): CreateChoicePayload
  createChoiceAnswer(input: CreateChoiceAnswerInput!): CreateChoiceAnswerPayload
  createGroup(input: CreateGroupInput!): CreateGroupPayload
  createNumberAnswer(input: CreateNumberAnswerInput!): CreateNumberAnswerPayload
  createPost(input: CreatePostInput!): CreatePostPayload
  createQuestion(input: CreateQuestionInput!): CreateQuestionPayload
  createSurvey(input: CreateSurveyInput!): CreateSurveyPayload
  createTextAnswer(input: CreateTextAnswerInput!): CreateTextAnswerPayload
  createTopic(input: CreateTopicInput!): CreateTopicPayload
  createUser(input: CreateUserInput!): CreateUserPayload
  deleteAppointment(input: DeleteAppointmentInput!): DeleteAppointmentPayload
  deleteBoard(input: DeleteBoardInput!): DeleteBoardPayload
  deleteChoice(input: DeleteChoiceInput!): DeleteChoicePayload
  deleteChoiceAnswer(input: DeleteChoiceAnswerInput!): DeleteChoiceAnswerPayload
  deleteNumberAnswer(input: DeleteNumberAnswerInput!): DeleteNumberAnswerPayload
  deletePost(input: DeletePostInput!): DeletePostPayload
  deleteQuestion(input: DeleteQuestionInput!): DeleteQuestionPayload
  deleteSurvey(input: DeleteSurveyInput!): DeleteSurveyPayload
  deleteTextAnswer(input: DeleteTextAnswerInput!): DeleteTextAnswerPayload
  deleteTopic(input: DeleteTopicInput!): DeleteTopicPayload
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  refreshToken(token: String!): Refresh
  "Obtain JSON Web Token mutation"
  tokenAuth(password: String!, username: String!): ObtainJSONWebToken
  updateAppointment(input: UpdateAppointmentInput!): UpdateAppointmentPayload
  updateBoard(input: UpdateBoardInput!): UpdateBoardPayload
  updateChoice(input: UpdateChoiceInput!): UpdateChoicePayload
  updateChoiceAnswer(input: UpdateChoiceAnswerInput!): UpdateChoiceAnswerPayload
  updateGroup(input: UpdateGroupInput!): UpdateGroupPayload
  updateNumberAnswer(input: UpdateNumberAnswerInput!): UpdateNumberAnswerPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  updateQuestion(input: UpdateQuestionInput!): UpdateQuestionPayload
  updateSurvey(input: UpdateSurveyInput!): UpdateSurveyPayload
  updateTextAnswer(input: UpdateTextAnswerInput!): UpdateTextAnswerPayload
  updateTopic(input: UpdateTopicInput!): UpdateTopicPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  verifyToken(token: String!): Verify
}

type NumberAnswerType implements Node {
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  numberAnswer: Int
  question: QuestionType
  updatedOn: DateTime
}

type NumberAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [NumberAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `NumberAnswerType` and its cursor."
type NumberAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: NumberAnswerType
}

"Obtain JSON Web Token mutation"
type ObtainJSONWebToken {
  token: String
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PostType implements Node {
  createdAt: DateTime
  createdBy: UserType
  "The ID of the object."
  id: ID!
  message: String
  topic: TopicType
  updatedAt: DateTime
  updatedBy: UserType
}

type PostTypeConnection {
  "Contains the nodes in this connection."
  edges: [PostTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `PostType` and its cursor."
type PostTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: PostType
}

type Query {
  "The ID of the object"
  getAppointment(id: ID!): AppointmentType
  getAppointments(
    after: String
    appointmentEnd: DateTime
    appointmentStart: DateTime
    before: String
    first: Int
    last: Int
    taken: Boolean
    title: String
  ): AppointmentTypeConnection
  "The ID of the object"
  getBoard(id: ID!): BoardType
  getBoards(
    after: String
    before: String
    creator: ID
    description: String
    first: Int
    last: Int
    name: String
  ): BoardTypeConnection
  "The ID of the object"
  getCheckup(id: ID!): CheckupType
  "The ID of the object"
  getChoice(id: ID!): ChoiceType
  "The ID of the object"
  getChoiceAnswer(id: ID!): ChoiceAnswerType
  getChoiceAnswers(
    after: String
    before: String
    choiceAnswer: ID
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    question: ID
    updatedOn: DateTime
  ): ChoiceAnswerTypeConnection
  getChoices(
    after: String
    before: String
    choiceText: String
    first: Int
    last: Int
    question: ID
  ): ChoiceTypeConnection
  "The ID of the object"
  getGroup(id: ID!): GroupType
  getGroups(
    after: String
    before: String
    first: Int
    id: ID
    last: Int
  ): GroupTypeConnection
  getMe: UserType
  "The ID of the object"
  getNumberAnswer(id: ID!): NumberAnswerType
  getNumberAnswers(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    numberAnswer: Int
    question: ID
    updatedOn: DateTime
  ): NumberAnswerTypeConnection
  "The ID of the object"
  getPost(id: ID!): PostType
  getPosts(
    after: String
    before: String
    createdAt: DateTime
    createdBy: ID
    first: Int
    last: Int
    message: String
    topic: ID
    updatedAt: DateTime
  ): PostTypeConnection
  "The ID of the object"
  getQuestion(id: ID!): QuestionType
  getQuestions(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    questionText: String
    questionType: String
    survey: ID
    updatedBy: ID
    updatedOn: DateTime
  ): QuestionTypeConnection
  getStudies(
    after: String
    before: String
    first: Int
    last: Int
    name: String
  ): StudyTypeConnection
  "The ID of the object"
  getSurvey(id: ID!): SurveyType
  getSurveys(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    description: String
    first: Int
    last: Int
    pubDate: DateTime
    surveyName: String
    updatedBy: ID
    updatedOn: DateTime
  ): SurveyTypeConnection
  "The ID of the object"
  getTextAnswer(id: ID!): TextAnswerType
  getTextAnswers(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    question: ID
    textAnswer: String
    updatedOn: DateTime
  ): TextAnswerTypeConnection
  "The ID of the object"
  getTopic(id: ID!): TopicType
  getTopics(
    after: String
    before: String
    board: ID
    creator: ID
    first: Int
    last: Int
    lastUpdated: DateTime
    subject: String
  ): TopicTypeConnection
  "The ID of the object"
  getUser(id: ID!): UserType
  getUserGroup: String
  getUsers(
    after: String
    before: String
    dateJoined: DateTime
    email: String
    first: Int
    id: ID
    isActive: Boolean
    isStaff: Boolean
    last: Int
    passwordChanged: Boolean
    username: String
  ): UserTypeConnection
}

type QuestionType implements Node {
  choiceSet(
    after: String
    before: String
    first: Int
    last: Int
  ): ChoiceTypeConnection!
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  questionText: String
  questionType: QuestionQuestionType
  survey: SurveyType
  updatedBy: UserType
  updatedOn: DateTime
}

type QuestionTypeConnection {
  "Contains the nodes in this connection."
  edges: [QuestionTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `QuestionType` and its cursor."
type QuestionTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: QuestionType
}

type Refresh {
  payload: GenericScalar
  token: String
}

type StudyType implements Node {
  checkupSet(
    after: String
    before: String
    first: Int
    last: Int
  ): CheckupTypeConnection!
  customuserSet(
    after: String
    before: String
    first: Int
    last: Int
  ): UserTypeConnection!
  "The ID of the object."
  id: ID!
  name: String
}

type StudyTypeConnection {
  "Contains the nodes in this connection."
  edges: [StudyTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `StudyType` and its cursor."
type StudyTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: StudyType
}

type SurveyType implements Node {
  createdBy: UserType
  createdOn: DateTime
  description: String
  "The ID of the object."
  id: ID!
  pubDate: DateTime
  questionSet(
    after: String
    before: String
    first: Int
    last: Int
  ): QuestionTypeConnection!
  surveyName: String
  updatedBy: UserType
  updatedOn: DateTime
}

type SurveyTypeConnection {
  "Contains the nodes in this connection."
  edges: [SurveyTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `SurveyType` and its cursor."
type SurveyTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: SurveyType
}

type TextAnswerType implements Node {
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  question: QuestionType
  textAnswer: String
  updatedOn: DateTime
}

type TextAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [TextAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `TextAnswerType` and its cursor."
type TextAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: TextAnswerType
}

type TopicType implements Node {
  board: BoardType
  creator: UserType
  "The ID of the object."
  id: ID!
  lastUpdated: DateTime
  postSet(
    after: String
    before: String
    first: Int
    last: Int
  ): PostTypeConnection!
  subject: String
}

type TopicTypeConnection {
  "Contains the nodes in this connection."
  edges: [TopicTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `TopicType` and its cursor."
type TopicTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: TopicType
}

type UpdateAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
}

type UpdateBoardPayload {
  board: BoardType
  clientMutationId: String
}

type UpdateChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
}

type UpdateChoicePayload {
  choice: ChoiceType
  clientMutationId: String
}

type UpdateGroupPayload {
  clientMutationId: String
}

type UpdateNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
}

type UpdatePostPayload {
  clientMutationId: String
  post: PostType
}

type UpdateQuestionPayload {
  clientMutationId: String
  question: QuestionType
}

type UpdateSurveyPayload {
  clientMutationId: String
  survey: SurveyType
}

type UpdateTextAnswerPayload {
  clientMutationId: String
  textAnswer: TextAnswerType
}

type UpdateTopicPayload {
  clientMutationId: String
  topic: TopicType
}

type UpdateUserPayload {
  clientMutationId: String
  user: UserType
}

type UserType implements Node {
  dateJoined: DateTime
  email: String
  "The ID of the object."
  id: ID!
  isActive: Boolean!
  isStaff: Boolean!
  passwordChanged: Boolean!
  studyParticipation: StudyType
  username: String
}

type UserTypeConnection {
  "Contains the nodes in this connection."
  edges: [UserTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `UserType` and its cursor."
type UserTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: UserType
}

type Verify {
  payload: GenericScalar
}

"An enumeration."
enum QuestionQuestionType {
  #choice
  CHOICE
  #number
  NUMBER
  #text
  TEXT
}

input CreateAppointmentInput {
  appointmentEnd: DateTime!
  appointmentStart: DateTime!
  clientMutationId: String
  commentDoctor: String
  patient: ID
  title: String!
}

input CreateBoardInput {
  clientMutationId: String
  description: String!
  name: String!
}

input CreateChoiceAnswerInput {
  choiceAnswer: ID!
  clientMutationId: String
  question: ID!
}

input CreateChoiceInput {
  choiceText: String!
  clientMutationId: String
  question: ID!
}

input CreateGroupInput {
  clientMutationId: String
  name: String
}

input CreateNumberAnswerInput {
  clientMutationId: String
  numberAnswer: String!
  question: ID!
}

input CreatePostInput {
  clientMutationId: String
  message: String!
  topic: ID!
}

input CreateQuestionInput {
  clientMutationId: String
  questionText: String!
  questionType: String!
  survey: ID!
}

input CreateSurveyInput {
  clientMutationId: String
  description: String!
  pubDate: DateTime
  surveyName: String!
}

input CreateTextAnswerInput {
  clientMutationId: String
  question: ID!
  textAnswer: String!
}

input CreateTopicInput {
  board: ID!
  clientMutationId: String
  subject: String!
}

input CreateUserInput {
  clientMutationId: String
  email: String!
  emailNotification: Boolean
  group: String
  isActive: Boolean!
  isStaff: Boolean!
  password: String!
  username: String!
}

input DeleteAppointmentInput {
  clientMutationId: String
  id: ID!
  removePatient: Boolean
}

input DeleteBoardInput {
  clientMutationId: String
  id: ID!
}

input DeleteChoiceAnswerInput {
  clientMutationId: String
  id: ID!
}

input DeleteChoiceInput {
  clientMutationId: String
  id: ID!
}

input DeleteNumberAnswerInput {
  clientMutationId: String
}

input DeletePostInput {
  clientMutationId: String
  id: ID!
}

input DeleteQuestionInput {
  clientMutationId: String
}

input DeleteSurveyInput {
  clientMutationId: String
  id: ID!
}

input DeleteTextAnswerInput {
  clientMutationId: String
}

input DeleteTopicInput {
  clientMutationId: String
  id: ID!
}

input DeleteUserInput {
  clientMutationId: String
  id: ID!
}

input UpdateAppointmentInput {
  appointmentEnd: DateTime
  appointmentStart: DateTime
  clientMutationId: String
  commentDoctor: String
  commentPatient: String
  id: ID!
  patient: ID
  taken: Boolean
  title: String
}

input UpdateBoardInput {
  clientMutationId: String
  description: String
  id: ID!
  name: String
}

input UpdateChoiceAnswerInput {
  choiceAnswer: ID
  clientMutationId: String
  id: ID!
  question: ID
}

input UpdateChoiceInput {
  choiceText: String
  clientMutationId: String
  id: ID!
  question: ID
}

input UpdateGroupInput {
  clientMutationId: String
  groupStr: String
  userId: ID
}

input UpdateNumberAnswerInput {
  clientMutationId: String
  id: ID!
  numberAnswer: String
  question: ID
}

input UpdatePostInput {
  clientMutationId: String
  id: ID!
  message: String
  topic: ID
}

input UpdateQuestionInput {
  clientMutationId: String
  id: ID!
  questionText: String
  questionType: String
  survey: ID
}

input UpdateSurveyInput {
  clientMutationId: String
  description: String
  id: ID!
  pubDate: DateTime
  surveyName: String
}

input UpdateTextAnswerInput {
  clientMutationId: String
  id: ID!
  question: ID
  textAnswer: String
}

input UpdateTopicInput {
  board: ID
  clientMutationId: String
  id: ID!
  subject: String
}

input UpdateUserInput {
  addGroup: String
  called: Boolean
  clientMutationId: String
  email: String
  emailNotification: Boolean
  id: ID!
  isActive: Boolean
  isStaff: Boolean
  password: String
  removeGroup: String
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar
