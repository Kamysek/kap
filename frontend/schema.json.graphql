# This file was generated based on "schema.json". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"An object with an ID"
interface Node {
  "The ID of the object."
  id: ID!
}

type AppointmentType implements Node {
  appointmentEnd: DateTime
  appointmentStart: DateTime
  commentDoctor: String
  commentPatient: String
  createdAt: DateTime
  dayReminder: Boolean!
  "The ID of the object."
  id: ID!
  noshow: Boolean!
  patient: UserType
  taken: Boolean!
  title: String
  weekReminder: Boolean!
}

type AppointmentTypeConnection {
  "Contains the nodes in this connection."
  edges: [AppointmentTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `AppointmentType` and its cursor."
type AppointmentTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AppointmentType
}

type BookSlotsPayload {
  appointmentList: [ID]
  clientMutationId: String
}

type CheckupType implements Node {
  daysUntil: Int
  "The ID of the object."
  id: ID!
  name: String
  study: StudyType
}

type CheckupTypeConnection {
  "Contains the nodes in this connection."
  edges: [CheckupTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `CheckupType` and its cursor."
type CheckupTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: CheckupType
}

type ChoiceAnswerType implements Node {
  choiceAnswer: ChoiceType
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  question: QuestionType
  updatedOn: DateTime
}

type ChoiceAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [ChoiceAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `ChoiceAnswerType` and its cursor."
type ChoiceAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: ChoiceAnswerType
}

type ChoiceType implements Node {
  choiceText: String!
  choiceanswerSet(
    after: String
    before: String
    first: Int
    last: Int
  ): ChoiceAnswerTypeConnection!
  "The ID of the object."
  id: ID!
  question: QuestionType!
}

type ChoiceTypeConnection {
  "Contains the nodes in this connection."
  edges: [ChoiceTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `ChoiceType` and its cursor."
type ChoiceTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: ChoiceType
}

type CreateAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
}

type CreateAppointmentsPayload {
  appointments: [AppointmentType]
  clientMutationId: String
}

type CreateChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
}

type CreateChoicePayload {
  choice: ChoiceType
  clientMutationId: String
}

type CreateGroupPayload {
  clientMutationId: String
  group: GroupType
}

type CreateNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
}

type CreateQuestionPayload {
  clientMutationId: String
  question: QuestionType
}

type CreateSurveyPayload {
  clientMutationId: String
  survey: SurveyType
}

type CreateTextAnswerPayload {
  clientMutationId: String
  textAnswer: TextAnswerType
}

type CreateUserPayload {
  clientMutationId: String
  user: UserType
}

type DeleteAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
  ok: Boolean
}

type DeleteChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
  ok: Boolean
}

type DeleteChoicePayload {
  choice: ChoiceType
  clientMutationId: String
  ok: Boolean
}

type DeleteNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
  ok: Boolean
}

type DeleteQuestionPayload {
  clientMutationId: String
  ok: Boolean
  question: QuestionType
}

type DeleteSurveyPayload {
  clientMutationId: String
  ok: Boolean
  survey: SurveyType
}

type DeleteTextAnswerPayload {
  clientMutationId: String
  ok: Boolean
  textAnswer: TextAnswerType
}

type DeleteUserPayload {
  clientMutationId: String
  ok: Boolean
  user: UserType
}

type GroupType implements Node {
  "The ID of the object."
  id: ID!
  name: String!
  "The groups this user belongs to. A user will get all permissions granted to each of their groups."
  userSet(
    after: String
    before: String
    first: Int
    last: Int
  ): UserTypeConnection!
}

type GroupTypeConnection {
  "Contains the nodes in this connection."
  edges: [GroupTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `GroupType` and its cursor."
type GroupTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: GroupType
}

type Mutation {
  bookSlots(input: BookSlotsInput!): BookSlotsPayload
  createAppointment(input: CreateAppointmentInput!): CreateAppointmentPayload
  createAppointments(input: CreateAppointmentsInput!): CreateAppointmentsPayload
  createChoice(input: CreateChoiceInput!): CreateChoicePayload
  createChoiceAnswer(input: CreateChoiceAnswerInput!): CreateChoiceAnswerPayload
  createGroup(input: CreateGroupInput!): CreateGroupPayload
  createNumberAnswer(input: CreateNumberAnswerInput!): CreateNumberAnswerPayload
  createQuestion(input: CreateQuestionInput!): CreateQuestionPayload
  createSurvey(input: CreateSurveyInput!): CreateSurveyPayload
  createTextAnswer(input: CreateTextAnswerInput!): CreateTextAnswerPayload
  createUser(input: CreateUserInput!): CreateUserPayload
  deleteAppointment(input: DeleteAppointmentInput!): DeleteAppointmentPayload
  deleteChoice(input: DeleteChoiceInput!): DeleteChoicePayload
  deleteChoiceAnswer(input: DeleteChoiceAnswerInput!): DeleteChoiceAnswerPayload
  deleteNumberAnswer(input: DeleteNumberAnswerInput!): DeleteNumberAnswerPayload
  deleteQuestion(input: DeleteQuestionInput!): DeleteQuestionPayload
  deleteSurvey(input: DeleteSurveyInput!): DeleteSurveyPayload
  deleteTextAnswer(input: DeleteTextAnswerInput!): DeleteTextAnswerPayload
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  refreshToken(token: String!): Refresh
  "Obtain JSON Web Token mutation"
  tokenAuth(password: String!, username: String!): ObtainJSONWebToken
  updateAppointment(input: UpdateAppointmentInput!): UpdateAppointmentPayload
  updateChoice(input: UpdateChoiceInput!): UpdateChoicePayload
  updateChoiceAnswer(input: UpdateChoiceAnswerInput!): UpdateChoiceAnswerPayload
  updateGroup(input: UpdateGroupInput!): UpdateGroupPayload
  updateNumberAnswer(input: UpdateNumberAnswerInput!): UpdateNumberAnswerPayload
  updateQuestion(input: UpdateQuestionInput!): UpdateQuestionPayload
  updateSurvey(input: UpdateSurveyInput!): UpdateSurveyPayload
  updateTextAnswer(input: UpdateTextAnswerInput!): UpdateTextAnswerPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  verifyToken(token: String!): Verify
}

type NumberAnswerType implements Node {
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  numberAnswer: Int
  question: QuestionType
  updatedOn: DateTime
}

type NumberAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [NumberAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `NumberAnswerType` and its cursor."
type NumberAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: NumberAnswerType
}

"Obtain JSON Web Token mutation"
type ObtainJSONWebToken {
  token: String
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type Query {
  "The ID of the object"
  getAppointment(id: ID!): AppointmentType
  getAppointments(
    after: String
    appointmentEnd: DateTime
    appointmentStart: DateTime
    before: String
    first: Int
    last: Int
    taken: Boolean
    title: String
  ): AppointmentTypeConnection
  "The ID of the object"
  getCheckup(id: ID!): CheckupType
  "The ID of the object"
  getChoice(id: ID!): ChoiceType
  "The ID of the object"
  getChoiceAnswer(id: ID!): ChoiceAnswerType
  getChoiceAnswers(
    after: String
    before: String
    choiceAnswer: ID
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    question: ID
    updatedOn: DateTime
  ): ChoiceAnswerTypeConnection
  getChoices(
    after: String
    before: String
    choiceText: String
    first: Int
    last: Int
    question: ID
  ): ChoiceTypeConnection
  "The ID of the object"
  getGroup(id: ID!): GroupType
  getGroups(
    after: String
    before: String
    first: Int
    id: ID
    last: Int
  ): GroupTypeConnection
  getMe: UserType
  "The ID of the object"
  getNumberAnswer(id: ID!): NumberAnswerType
  getNumberAnswers(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    numberAnswer: Int
    question: ID
    updatedOn: DateTime
  ): NumberAnswerTypeConnection
  "The ID of the object"
  getQuestion(id: ID!): QuestionType
  getQuestions(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    questionText: String
    questionType: String
    survey: ID
    updatedBy: ID
    updatedOn: DateTime
  ): QuestionTypeConnection
  getSlotLists(
    date: DateTime!
    minusdays: Int
    plusdays: Int
  ): [[AppointmentType]]
  getStudies(
    after: String
    before: String
    first: Int
    last: Int
    name: String
  ): StudyTypeConnection
  "The ID of the object"
  getSurvey(id: ID!): SurveyType
  getSurveys(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    description: String
    first: Int
    last: Int
    pubDate: DateTime
    surveyName: String
    updatedBy: ID
    updatedOn: DateTime
  ): SurveyTypeConnection
  "The ID of the object"
  getTextAnswer(id: ID!): TextAnswerType
  getTextAnswers(
    after: String
    before: String
    createdBy: ID
    createdOn: DateTime
    first: Int
    last: Int
    question: ID
    textAnswer: String
    updatedOn: DateTime
  ): TextAnswerTypeConnection
  "The ID of the object"
  getUser(id: ID!): UserType
  getUserGroup: String
  getUsers(
    after: String
    before: String
    dateJoined: DateTime
    email: String
    first: Int
    id: ID
    isActive: Boolean
    isStaff: Boolean
    last: Int
    passwordChanged: Boolean
    username: String
  ): UserTypeConnection
}

type QuestionType implements Node {
  choiceSet(
    after: String
    before: String
    first: Int
    last: Int
  ): ChoiceTypeConnection!
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  questionText: String
  questionType: QuestionQuestionType
  survey: SurveyType
  updatedBy: UserType
  updatedOn: DateTime
}

type QuestionTypeConnection {
  "Contains the nodes in this connection."
  edges: [QuestionTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `QuestionType` and its cursor."
type QuestionTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: QuestionType
}

type Refresh {
  payload: GenericScalar
  token: String
}

type StudyType implements Node {
  checkupSet(
    after: String
    before: String
    first: Int
    last: Int
  ): CheckupTypeConnection!
  customuserSet(
    after: String
    before: String
    first: Int
    last: Int
  ): UserTypeConnection!
  "The ID of the object."
  id: ID!
  name: String
}

type StudyTypeConnection {
  "Contains the nodes in this connection."
  edges: [StudyTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `StudyType` and its cursor."
type StudyTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: StudyType
}

type SurveyType implements Node {
  createdBy: UserType
  createdOn: DateTime
  description: String
  "The ID of the object."
  id: ID!
  pubDate: DateTime
  questionSet(
    after: String
    before: String
    first: Int
    last: Int
  ): QuestionTypeConnection!
  surveyName: String
  updatedBy: UserType
  updatedOn: DateTime
}

type SurveyTypeConnection {
  "Contains the nodes in this connection."
  edges: [SurveyTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `SurveyType` and its cursor."
type SurveyTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: SurveyType
}

type TextAnswerType implements Node {
  createdBy: UserType
  createdOn: DateTime
  "The ID of the object."
  id: ID!
  question: QuestionType
  textAnswer: String
  updatedOn: DateTime
}

type TextAnswerTypeConnection {
  "Contains the nodes in this connection."
  edges: [TextAnswerTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `TextAnswerType` and its cursor."
type TextAnswerTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: TextAnswerType
}

type UpdateAppointmentPayload {
  appointment: AppointmentType
  clientMutationId: String
}

type UpdateChoiceAnswerPayload {
  choiceAnswer: ChoiceAnswerType
  clientMutationId: String
}

type UpdateChoicePayload {
  choice: ChoiceType
  clientMutationId: String
}

type UpdateGroupPayload {
  clientMutationId: String
}

type UpdateNumberAnswerPayload {
  clientMutationId: String
  numberAnswer: NumberAnswerType
}

type UpdateQuestionPayload {
  clientMutationId: String
  question: QuestionType
}

type UpdateSurveyPayload {
  clientMutationId: String
  survey: SurveyType
}

type UpdateTextAnswerPayload {
  clientMutationId: String
  textAnswer: TextAnswerType
}

type UpdateUserPayload {
  clientMutationId: String
  user: UserType
}

type UserType implements Node {
  dateJoined: DateTime
  email: String
  "The ID of the object."
  id: ID!
  isActive: Boolean!
  isStaff: Boolean!
  passwordChanged: Boolean!
  studyParticipation: StudyType
  username: String
}

type UserTypeConnection {
  "Contains the nodes in this connection."
  edges: [UserTypeEdge]!
  "Pagination data for this connection."
  pageInfo: PageInfo!
}

"A Relay edge containing a `UserType` and its cursor."
type UserTypeEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: UserType
}

type Verify {
  payload: GenericScalar
}

"An enumeration."
enum QuestionQuestionType {
  #choice
  CHOICE
  #number
  NUMBER
  #text
  TEXT
}

input AppointmentInput {
  appointmentEnd: DateTime!
  appointmentStart: DateTime!
  commentDoctor: String
  patient: ID
  title: String!
}

input BookSlotsInput {
  appointmentList: [ID]
  clientMutationId: String
}

input CreateAppointmentInput {
  appointmentEnd: DateTime!
  appointmentStart: DateTime!
  clientMutationId: String
  commentDoctor: String
  patient: ID
  title: String!
}

input CreateAppointmentsInput {
  appointments: [AppointmentInput]
  clientMutationId: String
}

input CreateChoiceAnswerInput {
  choiceAnswer: ID!
  clientMutationId: String
  question: ID!
}

input CreateChoiceInput {
  choiceText: String!
  clientMutationId: String
  question: ID!
}

input CreateGroupInput {
  clientMutationId: String
  name: String
}

input CreateNumberAnswerInput {
  clientMutationId: String
  numberAnswer: String!
  question: ID!
}

input CreateQuestionInput {
  clientMutationId: String
  questionText: String!
  questionType: String!
  survey: ID!
}

input CreateSurveyInput {
  clientMutationId: String
  description: String!
  pubDate: DateTime
  surveyName: String!
}

input CreateTextAnswerInput {
  clientMutationId: String
  question: ID!
  textAnswer: String!
}

input CreateUserInput {
  clientMutationId: String
  email: String!
  emailNotification: Boolean
  group: String
  isActive: Boolean!
  isStaff: Boolean!
  password: String!
  username: String!
}

input DeleteAppointmentInput {
  clientMutationId: String
  id: ID!
  removePatient: Boolean
}

input DeleteChoiceAnswerInput {
  clientMutationId: String
  id: ID!
}

input DeleteChoiceInput {
  clientMutationId: String
  id: ID!
}

input DeleteNumberAnswerInput {
  clientMutationId: String
}

input DeleteQuestionInput {
  clientMutationId: String
}

input DeleteSurveyInput {
  clientMutationId: String
  id: ID!
}

input DeleteTextAnswerInput {
  clientMutationId: String
}

input DeleteUserInput {
  clientMutationId: String
  id: ID!
}

input UpdateAppointmentInput {
  appointmentEnd: DateTime
  appointmentStart: DateTime
  clientMutationId: String
  commentDoctor: String
  commentPatient: String
  id: ID!
  patient: ID
  taken: Boolean
  title: String
}

input UpdateChoiceAnswerInput {
  choiceAnswer: ID
  clientMutationId: String
  id: ID!
  question: ID
}

input UpdateChoiceInput {
  choiceText: String
  clientMutationId: String
  id: ID!
  question: ID
}

input UpdateGroupInput {
  clientMutationId: String
  groupStr: String
  userId: ID
}

input UpdateNumberAnswerInput {
  clientMutationId: String
  id: ID!
  numberAnswer: String
  question: ID
}

input UpdateQuestionInput {
  clientMutationId: String
  id: ID!
  questionText: String
  questionType: String
  survey: ID
}

input UpdateSurveyInput {
  clientMutationId: String
  description: String
  id: ID!
  pubDate: DateTime
  surveyName: String
}

input UpdateTextAnswerInput {
  clientMutationId: String
  id: ID!
  question: ID
  textAnswer: String
}

input UpdateUserInput {
  addGroup: String
  called: Boolean
  clientMutationId: String
  email: String
  emailNotification: Boolean
  id: ID!
  isActive: Boolean
  isStaff: Boolean
  password: String
  removeGroup: String
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar
